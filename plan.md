### Этап 1. Уточнение требований и ограничения

- **Функциональные требования**:
  - Определить, какие категории событий (из 1–21, описанных в `api.html`) входят в **MVP** *(Minimum Viable Product, минимально жизнеспособный продукт)* сенсор-агента.
  - Зафиксировать требования по **SLA доставки** *(Service Level Agreement, «соглашение об уровне обслуживания»)* событий: допустимая задержка, допустимая потеря при перегрузке.
  - Уточнить, какие **фильтры/поля** нужны ПУ при запросе к сенсор-api (по времени, `alpha/omega`, `event_id`, текстовый поиск по `description` и т.д.).
- **Нефункциональные требования**:
  - Оценить целевой масштаб: количество хостов, среднее/пиковое число событий в секунду, горизонт хранения.
  - Зафиксировать требования по **безопасности**: уровень шифрования, политика управления сертификатами, логирование доступа.
  - Зафиксировать требования по **наблюдаемости**: какие метрики, логи и алерты нужны.
- **Выбор технологий**:
  - Выбрать язык/рантайм для **сенсор-агента** (с учетом производительности и требований к ресурсам).
  - Выбрать стек для **сенсор-api** (web‑фреймворк, БД для хранения событий).
  - Определить формат развёртывания: пакеты (`.deb`/`.rpm`) или контейнеры.

---

### Этап 2. Проектирование архитектуры

- **Общая схема взаимодействия**:
  - Агент → (HTTPS, mTLS) → сенсор-api → БД → ПУ (через внутренний API).
- **Интерфейсы**:
  - Зафиксировать внешний API агента (описанный в `api.html`) как неизменяемый **контракт**.
  - Спроектировать внутренний API между агентом и сенсор-api (если он отличается от внешнего): формат событий, пакетная отправка, подтверждения, ретраи.
  - Спроектировать API сенсор-api для ПУ:
    - получение последних событий с пагинацией/фильтрами;
    - (опционально) агрегирующие эндпоинты для статистики.
- **Схема данных**:
  - Определить модель `event` на стороне сенсор-api: `dt`, `alpha`, `omega`, `event_id`, `description`, а также технические поля (`id`, `received_at`, `source_host` и др.).
  - Спроектировать индексы (по времени, `alpha`, `omega`, `event_id`), политику удаления/ротации для хранения последних N≈100k событий.
- **Безопасность**:
  - Использовать **клиентские сертификаты** для доступа к API агента (как в `api.html`).
  - Реализовать аутентификацию агентов на сенсор-api (mTLS, привязка сертификата к `alpha/omega` и хосту).
  - Спроектировать логирование доступа и критичных операций.

---

### Этап 3. Реализация сенсор-агента

- **3.1. Базовая инфраструктура агента**:
  - Определить структуру проекта, выделить модули: сборщики событий, транспорт, конфигурация, хранилище состояния, логирование.
  - Спроектировать формат и валидатор **конфигурационного файла** (адрес сенсор-api, политики буферизации, включенные источники событий).
  - Спроектировать локальное **хранилище состояния**:
    - что хранить (курсор по логам, хеши мониторимых файлов, информация об уже отправленных событиях);
    - где хранить (файл, embedded БД, журнал).
- **3.2. Модуль сбора событий**:
  - Для выбранных категорий (минимальный набор: `file_integrity`, `configuration`, `executable`, `storage`, `usb`, `authentication`, `network_activity` и др.) определить:
    - источники данных (auditd, journald/syslog, inotify/fanotify, `/proc`, systemd и т.п.);
    - маппинг «сырых» данных в формат события (`event_id`, строка `description` в формате, описанном в `api.html`).
  - Реализовать защиту от бурстов: дедупликацию/дебаунс, лимиты на частоту отправки одинаковых событий.
- **3.3. Транспортный слой агента**:
  - Реализовать клиент к сенсор-api (HTTPS, mTLS, ретраи с backoff, лимит параллельных запросов).
  - Реализовать очередь/буфер исходящих событий:
    - лимит по памяти/диску;
    - поведение при недоступности сенсор-api (локальный backlog, отбрасывание самых старых при переполнении).
- **3.4. Жизненный цикл и сервис**:
  - Реализовать демон: инициализация, основной цикл сбора/отправки, корректное завершение с сохранением состояния.
  - Подготовить юнит-файл **systemd** (или аналог) для запуска агента как сервиса.
- **3.5. Тестирование агента**:
  - Написать юнит-тесты для парсеров событий и конфигурации.
  - Подготовить интеграционные тесты:
    - имитация изменения файлов/подключения USB/сетевой активности и проверка генерации корректных событий;
    - проверка устойчивости к перезагрузкам хоста (сохранение/восстановление состояния).

---

### Этап 4. Реализация сенсор-api (фасад)

- **4.1. REST API для агентов**:
  - Спроектировать и реализовать эндпоинты приема событий (например, `POST /v1.0/events`/`/batch`), формат тела (одиночные/пакетные события по спецификации `api.html`).
  - Реализовать проверку и логирование клиентских сертификатов, маппинг сертификата на идентификаторы `alpha`, `omega`, `source_host`.
  - Реализовать обработку ошибок и защиту от перегрузки (rate limiting per agent, защита от заливания).
- **4.2. Хранилище событий**:
  - Выбрать и развернуть БД (PostgreSQL/ClickHouse/другое, в зависимости от требований).
  - Описать схему БД и миграции.
  - Реализовать логику **ограничения до N=100k**:
    - периодический джоб/процедуру, удаляющую старые записи;
    - либо кольцевой буфер в выбранной БД.
- **4.3. API для ПУ**:
  - Реализовать эндпоинты:
    - получение списка событий (аналог `GET /v1.0/events?limit=...`, расширенный фильтрами по времени, `event_id`, `alpha`, `omega` и др.);
    - (опционально) агрегирующие эндпоинты: количество событий по типам, тренды, статистика.
  - Реализовать пагинацию, сортировку по времени, сериализацию ответа в JSON-формат, совместимый с описанием в `api.html`.
- **4.4. Администрирование и наблюдаемость**:
  - Добавить метрики (например, через Prometheus): RPS, latency, коды ответов, размер очередей/объем БД.
  - Настроить техническое логирование: журнал запросов агентов, ошибки, превышение лимитов.
  - Реализовать health-check эндпоинт для балансировщиков/оркестратора.

---

### Этап 5. Интеграция и окружения

- **Dev/Stage/Prod окружения**:
  - Описать конфигурацию окружений (корневые сертификаты, адреса сенсор-api, параметры БД).
  - Подготовить скрипты/манифесты развёртывания (Docker Compose / Ansible / Kubernetes — согласно выбранной стратегии).
- **Интеграция агента и сенсор-api**:
  - Настроить процесс генерации и раскатки сертификатов для агентов (PKI, автоматизация, ротация).
  - Подготовить сценарии массовой установки агента (через Ansible/Puppet/Salt и т.п.).
  - Провести нагрузочное тестирование: эмуляция целевого числа хостов и потока событий, анализ производительности сенсор-api и БД.

---

### Этап 6. Безопасность и соответствие требованиям

- **Модель угроз**:
  - Провести анализ угроз (подмена агента, MITM, компрометация ключей, DoS на сенсор-api, инъекции в `description`).
  - Определить и реализовать меры защиты: ротация сертификатов, ограничение по IP/сети, rate limiting, валидация/нормализация входных данных.
- **Политики хранения и доступа**:
  - Определить, кто и как получает доступ к БД с событиями и логам сенсор-api.
  - Зафиксировать сроки хранения событий и, при необходимости, интеграцию с внешними системами архивирования.

---

### Этап 7. Документация и ввод в эксплуатацию

- **Документация**:
  - Подготовить руководство по установке и обновлению сенсор-агента (для администраторов серверов).
  - Описать API сенсор-api для ПУ (отдельно от API агента, описанного в `api.html`).
  - Задокументировать формат событий и привести типовые примеры (на основе «Примеры событий» из `api.html`).
- **Пилот и rollout**:
  - Провести пилот на ограниченном наборе серверов.
  - Собрать обратную связь, откорректировать конфигурации и лимиты.
  - Выполнить масштабное развёртывание и настроить мониторинг/алерты на продакшене.


